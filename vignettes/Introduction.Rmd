---
title: "Introduction"
output: 
  bookdown::html_document2:
    toc: true
bibliography: library.bib     
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


# Qubits and Quantum States

The term qubit (quantum bit) refers to a quantum system whose classical state set is $\{0, 1\}$. It is just a bit, but it can be in a quantum state. Quantum bit, i.e., qubit in quantum computing, is the elementary component of information and can be considered analogous to the 'bit' in classical computing. The quantum processor, which is used for quantum computing, handles information in the form of qubits. Qubits can be considered conceptual mathematical entities. The use of qubits as conceptual objects is of great advantage because quantum computation theory can be built for quantum data processing independent of any particular system.


# Quantum States and Representation

A quantum state of a system is represented by a column vector characterized by two properties:

1. The entries of a quantum state vector are complex numbers.
2. The sum of the absolute values squared of the entries of a quantum state vector must be equal to 1.

For a single qubit, the computational basis consists of two states: $|0⟩$ and $|1⟩$. These basis states are orthogonal, meaning they are independent of each other and can't be created by combining the other. To define $|0⟩$ with the `qsimulatR` package [@qsimulatR2023], the `qstate` function is available. 

```{r setup}
library(qsimulatR)
ket0 <- qstate(nbits = 1)
ket0
```

The `ket0` object represents the state $|0⟩$ in quantum notation. It's state structure can be examined using the `str()` function.

```{r str}
ket0 |> str()
```

This output represents the state $|0⟩$ in quantum notation, which produces a formal class object that belongs to the formal class `qstate` defined in the `qsimulatR` package. A breakdown of each part of the output follows:

- `nbits` represents the number of qubits in the quantum state. In this case, it's 1 qubit. 
- `coefs` contains the coefficients of the quantum state vector. Here, there are two coefficients:
  - `1+0i` corresponds to basis state $|0⟩$ and represents real number 1
  - `0+0i` corresponds to basis state $|1⟩$ and represents real number 0
- `basis` contains the names of the basis states corresponding to the coefficients in the `coefs` slot.
- `noise` contains information about noise parameters. In this case the noise parameters are not applied.
  - `p` probability 
  - `bits` number of bits 
  - `error` error type 
  - `args` additional arguments.
- `circuit` contains information about the quantum circuit associated with the quantum state: 
  - `ncbits` number of classical bits. The circuit has 0 classical bits.
  - `gatelist` list of gate operations. The circuit has an empty gatelist

Different `qstate` objects are specified by controlling the dimension and the coefficients. 

```{r ket1}
ket1 <- qstate(nbits = 1, coefs = c(0, 1))
ket1
```

The state structure of `ket1` can be examined as well.

```{r str1}
ket1 |> str()
```

Next, a state $|1⟩$ can also be defined by applying an X-gate to $|0⟩$.

```{r ket0}
ket1 <- X(1)*ket0
ket1
```

The structure of the state constructed this way produces the same quantum state representation.

```{r str0}
ket1 |> str()
```

From the previous `qstate` objects generated, taking the sum of absolute values squared ensures that the quantum states are normalized.

```{r sum}
Mod(ket0@coefs)^2
sum(Mod(ket0@coefs)^2)
```

By leveraging the functions `complex_check` and `normalize_check` from the `qvirus` package, researchers and developers can ensure the adherence of quantum state objects to fundamental quantum mechanics principles, thereby facilitating accurate and reliable quantum computations.

Now, the function `normalize_check` in `qvirus` also returns the sum of the absolute values of squared of the coefficients given a qstate object as input.

```{r norm}
library(qvirus)
normalize_check(ket0)
normalize_check(ket1)
```

Function `complex_check` also prints a complex class object from the given `qstate` objects `ket0` and `ket1`.

```{r compl}
complex_check(ket0)
complex_check(ket1)
```


# Understanding Superposition

A qubit can exist in states beyond just $|0⟩$ or $|1⟩$. This phenomenon is known as superposition, where the qubit can adopt any combination of the states $|0⟩$ and $|1⟩$. Superposition is a fundamental concept in quantum computing that enables qubits to exist in multiple states simultaneously, leading to exponential computational advantages. However, upon measurement, the superposition collapses, and the qubit takes on either the $|0⟩$ or $|1⟩$ state with probabilities determined by the coefficients ${\alpha}$ and ${\beta}$.

## Classical vs. Quantum Bits

Classically, a bit can be either 0 or 1, representing two distinct states. In contrast, a qubit, the quantum analogue of a classical bit, can exist in a superposition of these states, denoted as $|0⟩$ and $|1⟩$. The superposition state of a qubit $|\psi⟩$ can be mathematically represented as in Equation \@ref(eq:spos).

$$
\begin{equation}
    |\psi⟩ = \alpha|0⟩ + \beta|1⟩
    (\#eq:spos)
\end{equation}
$$
Here, $\alpha$ and $\betat$ are complex coefficients (amplitudes) satisfying the normalization condition of Equation \@ref(eq:norm).

$$
\begin{equation}
    |\alpha|² + |\beta|² = 1 
    (\#eq:norm)
\end{equation}
$$

## Conceptual Visualization


A qubit state can be represented as a unit sphere, with the north pole corresponding to $|0⟩$ and the south pole corresponding to $|1⟩$. The superposition state allows the qubit to exist at any point on this sphere, not just at the poles.

## Measurement and Collapse

When a qubit is observed or measured directly, it collapses from its superposition state to one of the possible states ($|0⟩$ or $|1⟩$), akin to Schrödinger's cat being either alive or dead upon observation. The probability of obtaining each outcome (0 or 1) upon measurement is determined by the squared magnitudes of the coefficients ($|\alpha|^2$ and $|\beta|^2$).

## Multi-Qubit Systems

In systems with multiple qubits, the computational space grows exponentially. For instance, a 3-qubit system can represent a superposition of all 8 possible values, demonstrating the exponential computational capacity of quantum computing compared to classical computing.

## Implementation Example

Implementing a qubit state that exemplifies superposition can be done via the state defined by Equation \@ref(eq:spsi).

$$
\begin{equation}
    |\psi⟩ = \left( \frac{1 + 2i}{3} \right)|0⟩ - \frac{2}{3}|1⟩
    (\#eq:spsi)
\end{equation}
$$
```{r spos}
psi <- qstate(nbits = 1, coefs = c((1+2i)/3, -2/3))
psi |> str()
```

The quantum state $|\psi⟩$ in Equation \@ref(eq:spsi) is a superposition of $|0⟩$ and $|1⟩$ states, as indicated by its complex coefficients.

To create superpositions of the states $|00⟩$, $|01⟩$, $|10⟩$, and $|11⟩$ in an implemented 2-qubit system described by a 4-dimensional complex vector space with four computational basis using `qsimulatR`, the coefficients for the superposition states must be defined. Then, the quantum state objects for each superposition state are created. Finally, validation checks are performed using `qvirus` functions to ensure the correctness of the quantum states.

```{r mspq}
# Define coefficients for the superposition states
alpha_00 <- 1 / sqrt(2)  # Coefficient for |00⟩
alpha_01 <- 1 / sqrt(2)  # Coefficient for |01⟩
alpha_10 <- 1 / sqrt(2)  # Coefficient for |10⟩
alpha_11 <- 1 / sqrt(2)  # Coefficient for |11⟩

# Create quantum state objects for the superposition states
ket00 <- qstate(nbits = 2, coefs = as.complex(c(alpha_00, 0, 0, 0)), basis = "|00>")
ket01 <- qstate(nbits = 2, coefs = as.complex(c(0, alpha_01, 0, 0)), basis = "|01>")
ket10 <- qstate(nbits = 2, coefs = as.complex(c(0, 0, alpha_10, 0)), basis = "|10>")
ket11 <- qstate(nbits = 2, coefs = as.complex(c(0, 0, 0, alpha_11)), basis = "|11>")
str(c(ket00,ket10,ket01,ket11))
```

The `qstate` object `psi` represents a superposition state in a 1-qubit system. The objects `ket00`, `ket01`, `ket10`, and `ket11` represent superposition states in a 2-qubit system. The basis fields in the outputs indicate the change of basis corresponding to the 2-qubit system for each state.

## Validation Checks

The properties of the superposition in the 1-qubit case can be validated using `complex_check` and `normalize_check` functions.

```{r spck}
complex_check(psi) 
normalize_check(psi)
```

For the 2-qubit state system the checks follow similarly. 

```{r mqbt}
# Validation checks
complex_check(ket00)  # Check coefficients of ket00 are complex
normalize_check(ket00)  # Check ket00 is normalized

complex_check(ket01)  # Check coefficients of ket01 are complex
normalize_check(ket01)  # Check ket01 is normalized

complex_check(ket10)  # Check coefficients of ket10 are complex
normalize_check(ket10)  # Check ket10 is normalized

complex_check(ket11)  # Check coefficients of ket11 are complex
normalize_check(ket11)  # Check ket11 is normalized
```

The `complex_check` confirms that the coefficients are complex number while `normalize_check` verifies that the states are normalized, with the sum of the absolute values squared equaling 1, as expected in quantum mechanics.

## Normalized (Pure) Quantum States

To create a superpositioned 2-qubit state in a 4-dimensional complex space with non-zero values in every entry, complex coefficients can be defined for each computational basis state of the 2-qubit system. The object `ket_superposition` is an example of such a state.

```{r npqs1}
# Define the complex coefficients for the superpositioned state
coefficients <- c(0.5+0.5i, 0.5-0.5i, -0.5+0.5i, -0.5-0.5i)

# Create the two-qubit state with the defined coefficients and basis states
ket_superposition <- qstate(nbits = 2, coefs = coefficients, basis = c("|00>", "|01>", "|10>", "|11>"))

# Display the structure of the created state
ket_superposition |> str()
```

The complex coefficients in a quantum state are defined to create a superpositioned state with non-zero values. The coefficients are chosen to create a superposition across all four computational basis states of the 2-qubit system. A `qstate` object is used to create the state with the specified coefficients and basis states. The structure of the created state is condidered and validation checks are performed on the created superpositioned 2-qubit state to verify if the coefficients of the state are complex numbers and the state is properly normalized.

```{r npqs2}
# Perform complex check on the superpositioned state
complex_check(ket_superposition)
# Perform normalize check on the superpositioned state
normalize_check(ket_superposition)
```

In quantum mechanics, normalized states are represented as vectors on the surface of a sphere called the Bloch sphere. The angle $\theta$ (ranging from 0 to 2$\pi$) determines the probability of measuring either the $|0⟩$ or $|1⟩$ states, while the angle $\phi$ (ranging from 0 to $\pi$) represents the relative phase.

Mathematically, a normalized quantum state can be written in the form of Equation \@ref(eq:pur1).

$$
\begin{equation}
    |\psi⟩ = \cos{\frac{\theta}{2}} |0⟩ + e^{i\phi} \sin{\frac{\theta}{2}}|1⟩
    (\#eq:pur1)
\end{equation}
$$
Here $∣\psi⟩$ represents the quantum state, $\theta$ is the angle that determines the probability amplitude of measuring the state $∣0⟩$ or $∣1⟩$ and $\phi$ is the phase angle that describes the relative phase between the states.

On the Bloch sphere, the vector representing state of Equation \@ref(eq:pur1) points to a specific location determined by $\theta$ and $\phi$, and its length is always 1, denoting the normalized state. This visual representation helps in understanding the state's properties and how measurements would behave in quantum systems.

In a 2-qubit system, a normalized (pure) quantum state can be represented as in Equation \@ref(eq:pu21)

$$
\begin{equation}
    |\psi⟩ = \alpha_{00}|00⟩ + \alpha_{01}∣01⟩ + \alpha_{10}∣10⟩ + \alpha_{11}∣11⟩
    (\#eq:pu21)
\end{equation}
$$

where $∣\alpha_{00}∣^2 + ∣\alpha_{01}∣^2 + ∣\alpha_{10}|^2 + ∣\alpha_{11}|^2 = 1$, due to normalization.

For simplicity of illustration, the specific state of Equation \@ref(eq:pu22) with equal coefficients for all basis states is considered.

$$
\begin{equation}
    |\psi⟩ = \frac{1}{2} ∣00⟩ + \frac{1}{2} ∣01⟩ + \frac{1}{2} ∣10⟩ + \frac{1}{2} ∣11⟩
    (\#eq:pu22)
\end{equation}
$$

This state corresponds to $\theta = \pi/2$ and $\phi = 0$ in the Bloch sphere representation.

On the Bloch sphere, the state in Equation \@ref(eq:pu22) is located at the equator (since $\theta = \pi/2$), and all points on the equator are equidistant from the north and south poles. This implies that all basis states in this superposition have equal probability amplitudes, making measurements equally likely to yield any of the four basis states $∣00⟩$, $∣01⟩$, $∣10⟩$, $∣11⟩$.

In the Bloch hyper-sphere representation each qubit corresponds to a separate Bloch sphere, and the overall state of the system exists in a higher-dimensional space. The state of the entire n-qubit system is represented as a point on the surface of the Bloch hyper-sphere. The dimensions of the Bloch hyper-sphere increase exponentially with the number of qubits. For n qubits, the Bloch hyper-sphere is a $2^n$-dimensional space. The angles $\theta$ and $\phi$ in the Bloch sphere representation for each qubit generalize to higher-dimensional analogues in the Bloch hyper-sphere.

The Bloch hyper-sphere provides a geometric way to understand the state of a multi-qubit system, just as the Bloch sphere does for a single qubit. It helps visualize superpositions, entanglement, and other quantum phenomena in higher-dimensional spaces, which can be challenging to conceptualize purely mathematically.

A given quantum state $∣\psi⟩$ in a n-qubit system can be expressed as in Equation \@ref(eq:purn) by generalizing the quantum state equation to an n-qubit system.

$$
\begin{equation}
    |\psi⟩ = \sum_{x_1, x_2, ..., x_n} a_{x_1x_2...x_n} ∣x_1x_2...x_n⟩
    (\#eq:purn)
\end{equation}
$$

Here $|\psi⟩$ represents the quantum state of the n-qubit system, $x_1, x_2,...,x_n$ are the individual qubit states, where each $x_i$ can be either 0 or 1. The coefficients $\alpha_{x_1x_2...x_n}$ are the complex coefficients or amplitudes associated with each computational basis state ∣$x_1x_2...x_n$⟩, where the sum is taken over all possible combinations of $x_1, x_2,..., x_n$, which gives the superposition of all basis states.

The generalization in Equation \@ref(eq:purn) maintains the concept of superposition, where the quantum state is a linear combination of all possible computational basis states. However, in higher dimensions (more qubits), the number of terms in the superposition and the complexity of the state increase exponentially, showcasing the power of quantum computing in handling vast amounts of information simultaneously.

The complex coefficients $\alpha_{x_1x_2...x_n}$ can be expressed in terms of trigonometric functions, similar to how states get represented on the Bloch sphere for the single qubit case of Equation \@ref(eq:pur1).

For a single qubit system, the complex coefficients can be written in the form of Equation \@ref(eq:cff1).

$$
\begin{equation}
    \alpha_0 = \cos{\frac{\theta}{2}} \\
    \alpha_1 = e^{i\phi} \sin{\frac{\theta}{2}}
    (\#eq:cff1)
\end{equation}
$$

In the general n-qubit case, where $x_1, x_2, ..., x_n$ represent the individual qubit states, the complex coefficients get expressed as in Equation \@ref(eq:cffn).

$$
\begin{equation}
    \alpha_{x_1x_2...x_n} = \prod_{x_1,...,x_n} \cos{\frac{\theta_i}{2}}^{1−x_i} e^{i\phi_i} \sin{\frac{\theta_i}{2}}^{x_i}
    (\#eq:cffn)
\end{equation}
$$
Here $\theta_i$ and $\phi_i$ are the angles that determine the probability amplitudes and relative phases for each qubit. The $x_i$ takes the value 0 or 1 for each qubit, indicating the state $∣0⟩$ or $∣1⟩$ respectively.

Expression \@ref(eq:cffn) generalizes the trigonometric representation of complex coefficients to n qubits, where each qubit contributes its own angle $\theta_i$ and phase $\phi_i$ to the overall quantum state, as a way to extend the concept of the Bloch sphere to higher-dimensional quantum systems, where the coordinates of the Bloch vector become more complex but still follow the principles of superposition and phase.

To prove that coefficients in Equation \qref(eq:cff1) define a quantum state, it is required to prove that the entries are complex numbers and that the normalization condition holds. 

For the 1-qubit system case, the general form of a normalized (pure) quantum state is given by Equation \@ref(eq:pu11).

$$
\begin{equation}
     |\psi⟩ = \alpha_0 ∣0⟩ + \alpha_1∣1⟩
    (\#eq:pu11)
\end{equation}
$$
Where $\alpha_0$ and $\alpha_1$ are complex coefficients as in Equation \@ref(eq:cff1), and $∣0⟩$ and $∣1⟩$ are the basis states of the qubit system. Both $\alpha_0$ and $\alpha_1$ involve trigonometric functions and exponentials. Trigonometric functions like cosine and sine can generate complex numbers, especially when combined with phases in the form of $e^{i \phi}$. Since $\alpha_0$ and $\alpha_1$ are combinations of such functions, they are indeed complex numbers.

The normalization condition for a quantum state is that the sum of the squared magnitudes of the coefficients must equal 1. Mathematically, this is expressed as Equation \@ref(eq:norm), where, substituing the expressions for $\alpha_0$ and $\alpha_1$ and simplifying to verify normalization results in Equation \@ref(eq:nr11).

$$
\begin{equation}
     |\alpha_0∣² + ∣\alpha_1∣^2 = \Big|\cos{\frac{\theta}{2}}\Big|^2 + \Big|e^{i\phi} \sin{\frac{\theta}{2}}\Big|^2 \\
    = \cos^2{\frac{\theta}{2}} + \Big(e^{i\phi} \sin{\frac{\theta}{2}}\Big) \Big(e^{−i\phi} \sin{\frac{\theta}{2}}\Big) \\
    = \cos^2{\frac{\theta}{2}} + \Big(e^{i\phi} \sin{\frac{\theta}{2}}\Big) \Big(e^{−i\phi} \sin{\frac{\theta}{2}}\Big) \\
    = \cos^2{\frac{\theta}{2}} + \sin^2{\frac{\theta}{2}} \\
    = 1
    (\#eq:nr11)
\end{equation}
$$

Therefore, the coefficients $\alpha_0$ and $\alpha_1$ are complex numbers and they satisfy the normalization condition for a quantum state in the 1-dimensional case. 

In the 2-qubit system, the quantum state is represented by Equation \@ref(eq:pu23).

$$
\begin{equation}
    ∣\psi⟩ = \alpha_{00}∣00⟩ + \alpha_{01}∣01⟩ + \alpha_{10}∣10⟩ + \alpha_{11}∣11⟩
    (\#eq:pu23)
\end{equation}
$$

Where $∣00⟩$, $∣01⟩$, $∣10⟩$, and $∣11⟩$ are the basis states of the 2-qubit system.

Similar to the 1-dimensional case, the complex coefficients $\alpha_{00}$, $\alpha_{01}$, $\alpha_{10}$, and $\alpha_{11}$ are expressed in terms of angles $\theta$ and $\phi$, as in Equation \@ref(eq:cff2).

$$
\begin{equation}
   \alpha_{00} = \cos{\frac{\theta_1}{2}} \cos{\frac{\theta_2}{2}} \\
   \alpha_{01} = e^{i\phi_{01}} \cos{\frac{\theta_1}{2}} \sin{\frac{\theta_2}{2}} \\
   \alpha_{10} = e^{i\phi_{10}} \cos{\frac{\theta_2}{2}} \sin{\frac{\theta_1}{2}} \\
   \alpha_{11} = e^{i(\phi_{01} + \phi_{10})} \sin{\frac{\theta_1}{2}} \sin{\frac{\theta_2}{2}}
  (\#eq:cff2)
\end{equation}
$$
To prove that coefficients in Equation \@ref(eq:pu23) define a quantum state, they must satisfy being complex numbers in every entry and the normalization condition.

Similar to the 1-dimensional case, the coefficients $\alpha_{00}$, $\alpha_{01}$, $\alpha_{10}$, and $\alpha_{11}$ involve trigonometric functions and exponentials. Since these functions can generate complex numbers, the coefficients are indeed complex.

To prove the normalization condition for a quantum state in the 2-dimensional case, a starting point begins with the parameterization given by Equation \@ref(eq:cff2), renaming each parameter $\alpha$, $\beta$, $\gamma$ and $\delta$ for each coefficient $\alpha_{00}$, $\alpha_{01}$, $\alpha_{10}$, and $\alpha_{11}$ respectively. Squaring each coefficient gives results in Equation \@ref(eq:nr21).

$$
\begin{equation}
     |\alpha∣^2 = \Big(\cos{\frac{\theta_1}{2}} \cos{\frac{\theta_2}{2}}\Big)^2 \\
     ∣\beta∣^2 = \Big|e^{i\phi_1} \sin{\frac{\theta_1}{2}} \cos{\frac{\theta_2}{2}}\Big|^2 \\
     ∣\gamma∣^2 = \Big|e^{i\phi_2} \cos\frac{\theta_1}{2} \sin{\frac{\theta_2}{2}}\Big|^2 \\
     |\delta∣² = \Big|e^{i(\phi_1 + \phi_2)} \sin{\frac{\theta_1}{2}} \sin{\frac{\theta_2}{2}}\Big|^2
    (\#eq:nr21)
\end{equation}
$$
Simplifying the squared magnitudes results in Equation \@ref(eq:nr22).

$$
\begin{equation}
     |\alpha∣^2 = \cos^2{\frac{\theta_1}{2}} \cos^2{\frac{\theta_2}{2}} \\
     ∣\beta∣^2 = \Big|\sin{\frac{\theta_1}{2}} \cos{\frac{\theta_2}{2}}\Big|^2 \\
     ∣\gamma∣^2 = \Big|\cos\frac{\theta_1}{2} \sin{\frac{\theta_2}{2}}\Big|^2 \\
     |\delta∣^2 = \Big|\sin{\frac{\theta_1}{2}} \sin{\frac{\theta_2}{2}}\Big|^2
    (\#eq:nr22)
\end{equation}
$$
Then, Equation \@ref(eq:nr23) is obtaied by applying trigonometric identities. 

$$
\begin{equation}
     ∣\alpha∣^2 = \frac{1 + \cos{\theta_1}}{2} \frac{1 + \cos{\theta_2}}{2} \\
     ∣\beta∣^2 = \frac{1 - \cos{\theta_1}}{2} \frac{1 + \cos{\theta_2}}{2} \\
     ∣\gamma∣^2 = \frac{1 + \cos{\theta_1}}{2} \frac{1 - \cos{\theta_2}}{2} \\
     ∣\delta∣^2 = \frac{1 − \cos{\theta_1}}{2} \frac{1 - \cos{\theta_2}}{2}
    (\#eq:nr23)
\end{equation}
$$
Expanding the products and simplifying further gives Equation \@ref(eq:nr24).

$$
\begin{equation}
     ∣\alpha∣^2 = \frac{1 + \cos{\theta_1} + \cos{\theta_2} + \cos{\theta_1}\cos{\theta_2}}{4} \\
     ∣\beta∣^2 = \frac{1 - \cos{\theta_1}+ \cos{\theta_2} - \cos{\theta_1}\cos{\theta_2}}{4} \\
     ∣\gamma∣^2 = \frac{1 + \cos{\theta_1} - \cos{\theta_2} - \cos{\theta_1}\cos{\theta_2}}{4} \\
     ∣\delta∣^2 = \frac{1 - \cos{\theta_1} - \cos{\theta_2} + \cos{\theta_1}\cos{\theta_2}}{4}
    (\#eq:nr24)
\end{equation}
$$
And therefore, combining the terms $∣\alpha|^2 + ∣\beta|^2 + ∣\gamma|^2+ |\delta|^2 = 1$.

It's been proven that the coefficients $\alpha_{00}$, $\alpha_{01}$, $\alpha_{10}$, and $\alpha_{11}$ are complex numbers and satisfy the normalization condition, defining a valid quantum state in the 2-dimensional case.

The previous results follow from the property that ∣$e^{i\phi}$∣ = 1 for any real value of $\phi$ and from the fact that the absolute value of a complex number $z = a + bi$ is given by $∣z∣ = \sqrt{a^2 + b^2}$. Then, $z = e^{i\phi_1} = \cos{\phi_1} + i\sin{\phi_1}$. Computing the absolute gives $|e^{i\phi_1}∣= |\sqrt{\cos^2{\phi_1} + \sin^2{\phi_1}}| = \sqrt{1} = 1$.

The trigonometric identity $\cos^2{\phi} + \sin^2{\phi} = 1$ holds for any real number $\phi$, which means that the absolute value of $e^{i\phi_1}$ is always 1 regardless of the value of $\phi_1$. Hence, ∣$e^{i\phi_1}$∣ = 1 for any real $\phi_1$.

Here are a few examples that represent 2-dimensional complex vectors with entries that sum to 1, that is, for the complex vector to represent a valid quantum state.

1. $\Big(\frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}}\Big)$. The squared magnitudes of both entries sum up to 1, making it a valid normalized vector.

2. $\Big(\frac{1}{2} + \frac{i}{2}, \frac{1}{2} - \frac{i}{2}\Big)$. Again, the squared magnitudes of both entries sum up to 1, satisfying the normalization condition.

3. $\Big(\frac{3}{5}, \frac{4i}{5}\Big)$. Here, the squared magnitudes are $\frac{9}{25} + \frac{16}{25} = 1$, fulfilling the normalization requirement.

These examples illustrate valid 2-dimensional complex vectors that represent quantum states.

The complex vectors as normalized pure quantum states in terms of their parameters for the first example, can be represented as a normalized pure quantum state $|\psi_1⟩$ with angle parameters $\theta_1 = \frac{\pi}{4}$ (45 degrees) and $\phi_1$ = 0 (No relative phase). The state of example 2 corresponds to a normalized pure quantum state $|\psi_2⟩$ with angle parameters $\theta_2 = \frac{\pi}{2}$ (90 degrees) and $\phi_2 = \frac{\pi}{2}$ (90 degrees, introducing a relative phase). Example 3 can be represented as a normalized pure quantum state ∣$\psi_3$⟩ with parameter $\theta_3$ such that $\cos{\theta_3} = \frac{3}{5}$, which leads to $\theta_3 \approx 0.927$ radians (or about 53.13 degrees). The angle $\phi_3$ is equal to $\frac{\pi}{2}$ (90 degrees with relative phase).

These parameters help describe the state of each quantum system in terms of its orientation on the Bloch sphere, where $\theta$ determines the probability amplitudes of measuring the state in the computational basis, and $\theta$ represents the relative phase between basis states.

To visualize the quantum states represented by the complex vectors on the Bloch sphere, for a given state $|\psi_i⟩$, the coordinates of the state are converted to spherical coordinates with given $\theta_i$ and $\phi_i$. Then a point on the Bloch sphere corresponding to these coordinates is plotted.

The `pure_qubit1` function in `qvirus` creates a normalized pure quantum state for a 1-qubit system   

```{r npqs3}
# Define the parameters
theta <- pi/4
phi <- pi/6

# Create the quantum state
psi_qubit1 <- pure_qubit1(theta, phi)
psi_qubit1 |> str()

# Validation checks
normalize_check(psi_qubit1)
complex_check(psi_qubit1)
```

This function calculates the coefficients for the given parameters `theta` and `phi` and creates the quantum state. Then validation checks are performed. The values of `theta` and `phi` get adjusted as needed for different states.

Similarly, `qvirus` includes the implementation of the `pure_qubit2` function that creates normalized pure 2-qubit system state representations.

```{r npqs4}
# Define the parameters
theta1 <- pi/3
theta2 <- pi/4
phi1 <- pi/6
phi2 <- pi/5

# Create the quantum state
psi_qubit2 <- pure_qubit2(theta1, theta2, phi1, phi2)
psi_qubit2 |> str()

# Validation checks
normalize_check(psi_qubit2)
complex_check(psi_qubit2)
```

The combination of mathematical representation, trigonometric functions, and Bloch sphere visualization provides a comprehensive framework for understanding and visualizing quantum states in multi-qubit systems. It forms the basis for analyzing quantum phenomena such as superposition and entanglement, essential for quantum computing and quantum information science.


# Measuring Quantum States

Measuring quantum states involves a fascinating interplay between quantum superposition and classical outcomes. 

## Quantum Measurement and Superposition Collapse

In quantum mechanics, when a quantum system is measured, its superposition collapses to a definite state. This process, known as wave function collapse or projection postulate, transitions the system from a combination of states to a single state. This transition is fundamental to extracting classical information from quantum states.

## Born Rule and Probability of Measurement Outcomes

The Born rule states that when measuring a quantum state, each classical state has a probability of being the measurement outcome. This probability is determined by the squared absolute value of the component in the quantum state vector corresponding to that classical state.

Considering the quantum state $∣\psi⟩$ of the illustration example in Equation \@ref(eq:spsi) with complex amplitudes $\alpha = \frac{1+2i}{3}$ and $\beta = -\frac{2}{3}$. The probability of measuring classical state is calculated as $Prob(0) = ∣\alpha∣^2 = ∣\frac{1+2i}{3}∣^2 = \frac{5}{9}$ and classical state 1 is obtained as $Prob(1) = ∣\beta∣^2 = ∣−\frac{2}{3}∣^2 = \frac{4}{9}$, therefore, these probabilities satisfy the condition that the sum of the squared absolute values of the components in the quantum state vector equals 1.

By setting the boolean argument `probs = TRUE` in the `normalize_check` function, the probabilities of being in classical states 0 and 1 for a given quantum state object $∣\psi⟩$ with normalized coefficients are obtained.

```{r mqso}
normalize_check(psi, probs = TRUE)
```

Here, the output represents the probabilities of measuring classical states 0 and 1, indicating a 55.56% chance of measuring state 0 and a $44.44\%$ chance of measuring state 1.

This demonstrates how quantum measurements yield probabilistic outcomes based on the components of the quantum state vector, bridging the quantum and classical worlds in a probabilistic manner.


# Bloch Sphere

In quantum mechanics, the Bloch sphere is a geometric representation of the pure state space of a 2-level quantum mechanical system. The Bloch sphere helps in the understanding of the geometric interpretation of unitary operations or gates performed on qubits.

From the normalized (pure) quantum state representation of Equation \@ref(eq:pur1) the angle $\theta \in [0, 2\pi]$ determines the probability to measure $∣0⟩$ or $∣1⟩$ states, and the angle $\phi \in [0, \pi]$ describes the relative phase. A relative phase is the difference between the phases of the coefficients of $∣0⟩$ and $∣1⟩$. Relative phase is the core of quantum computing. If there are 2 quantum states with different relative phases (i.e. 2 values of $\phi$) then both the qubit states are different.

The Bloch sphere is a sphere with radius r, where $|r| = 1$, and all normalized (pure) states are points on its surface. The antipodal points on a bloch sphere represent orthogonal vectors. Hence $∣0⟩$ and $∣1⟩$ are orthogonal vectors. The radius of the Bloch sphere is of length 1. Each point on the surface of the Bloch sphere is a unique quantum state.

The angles used in the Bloch sphere are twice as big as in the Hilbert space. For example, in the Hilbert space, the z-axis basis states $∣0⟩$ and $∣1⟩$ are orthogonal (the angle is $\pi/2 = 90°$), but in the Bloch sphere the angle between states $∣0⟩$ and $∣1⟩$ is 
$\pi = 180°$ (z-axis).

The coordinates of a state $|\psi⟩$ are given by the Bloch vector r in spherical coordinates as the colatitude with respect to the z-axis (parameter $\theta$) and the longitude with respect to the x-axis (parameter $\phi$). The specified point is obtained as in Equation \@ref(eq:bloch).

$$
\begin{equation}
     r = (\sin{\theta}\cos{\phi}, \sin{\theta}\sin{\phi}, \cos{\theta}) = (x, y, z)
     (\#eq:bloch)
\end{equation}
$$

There are 6 important states on the Bloch Sphere. 2 on the X-axis, 2 on the Z-axis and 2 on the Y-axis.

States in the z-axis are showed in Equation \@ref(eq:bspz), and they simply represent the $∣0⟩$ and $∣1⟩$ states.

$$
\begin{equation}
     |0⟩ = \begin{bmatrix} 
     1 \\ 
     0 \\ 
     \end{bmatrix} \\ ∣1⟩ = \begin{bmatrix} 
     0 \\ 
     1 \\ 
     \end{bmatrix}
     (\#eq:bspz)
\end{equation}
$$
In `qvirus` these are defined using `six_state` function, that returns states on the Bloch Sphere based on the specified indices of the states to include. For the standard z-axis, indices are 1,2.

```{r zass}
six_state(1)[[1]] |> str()
six_state(2)[[1]] |> str()
```

States in the x-axis are showed in Equation \@ref(eq:bspx).

$$
\begin{equation}
     |+⟩ = \frac{1}{\sqrt{2}} (∣0⟩ + ∣1⟩) = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     1 \\ 
     1 \\ 
     \end{bmatrix} \\ ∣-⟩ = \frac{1}{\sqrt{2}} (∣0⟩ - ∣1⟩) = \frac{1}{\sqrt{2}} \begin{bmatrix} 
      1 \\ 
     -1 \\ 
     \end{bmatrix}
     (\#eq:bspx)
\end{equation}
$$
The `qstate` representations of the x-axis states are given by superposition specifying indices 3,4 in `six_state`.

```{r xass}
six_state(3)[[1]] |> str()
six_state(4)[[1]] |> str()
```

The states in the y-axis are $∣+i⟩$ and $∣-i⟩$. They are showed in Equation \@ref(eq:bspy).

$$
\begin{equation}
     |+i⟩ = \frac{1}{\sqrt{2}} (∣0⟩ + i∣1⟩) = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     1 \\ 
     i \\ 
     \end{bmatrix} \\ ∣-i⟩ = \frac{1}{\sqrt{2}} (∣0⟩ - i∣1⟩) = \frac{1}{\sqrt{2}} \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix} 
     (\#eq:bspy)
\end{equation}
$$
Representations of the y-axis states are also given with `six_state` specifying indices 3,4.

```{r yass}
six_state(5)[[1]] |> str()
six_state(6)[[1]] |> str()
```

The Pauli-X, Pauli-Y and Pauli-Z matrices, are fundamental operators in quantum mechanics and quantum computing. They are widely used for various quantum operations and calculations. 

The eigenstates of the Pauli-X, Pauli-Y, and Pauli-Z matrices are the vectors that, when acted upon by the respective matrix, yield scalar multiples of themselves. In other words, they are the vectors that remain unchanged (up to a scalar factor) when operated on by these matrices. Mathematically, if A is a square matrix, x is the eigenvector of A and $\lambda$ is the eigenvalue of A then $Ax = \lambda x$.

First, considering the Z-Gate matrix in Equation \@ref(eq:pauz), eigenstates and eigenvalues can be studied. 

$$
\begin{equation}
    Z = \begin{bmatrix} 
     1 &  0 \\ 
     0 & -1 \\ 
     \end{bmatrix} 
     (\#eq:pauz)
\end{equation}
$$

Then, the equations for the eigenvalues and the eigenvectors are checked in Equation \@ref(eq:eigz).

$$
\begin{equation}
    Z∣0⟩ = \begin{bmatrix} 
     1 &  0 \\ 
     0 & -1 \\ 
     \end{bmatrix} \begin{bmatrix} 
     1 \\ 
     0 \\ 
     \end{bmatrix} = \begin{bmatrix} 
     1 \\ 
     0 \\ 
     \end{bmatrix} = ∣0⟩ \\
     \therefore Z∣0⟩ = Ax = \lambda x = (+1)∣0⟩ \\
         Z∣1⟩ = \begin{bmatrix} 
     1 &  0 \\ 
     0 & -1 \\ 
     \end{bmatrix} \begin{bmatrix} 
     0 \\ 
     1 \\ 
     \end{bmatrix} = \begin{bmatrix} 
      0 \\ 
     -1 \\ 
     \end{bmatrix} = -\begin{bmatrix} 
     0 \\ 
     1 \\ 
     \end{bmatrix} = -∣1⟩ \\
     \therefore Z∣1⟩ = Ax = \lambda x = (-1)∣1⟩
     (\#eq:eigz)
\end{equation}
$$
Hence +1 and -1 are the eigenvalues and $∣0⟩$ and $∣1⟩$ are the eigenvectors of the Pauli-Z matrix.

In `qsimulatR` the `Z` gate is specified with the `bit` argument set as an integer, the bit to which to apply the gate. Working with `qstate` objects eigenvalues are found.

```{r eigz}
Z(1)*six_state(1)[[1]]
Z(1)*six_state(2)[[1]]
```

Next, the X-Gate matrix in Equation \@ref(eq:paux) is analyzed. 

$$
\begin{equation}
    X = \begin{bmatrix} 
     0 & 1 \\ 
     1 & 0 \\ 
     \end{bmatrix} 
     (\#eq:paux)
\end{equation}
$$
And the equations for the eigenvalues and the eigenvectors are checked in Equation \@ref(eq:eigx), given the x-axis states of Equation \@ref(eq:bspx).

$$
\begin{equation}
    X∣+⟩ = \begin{bmatrix} 
     0 & 1 \\ 
     1 & 0 \\ 
     \end{bmatrix} \Bigg(\frac{1}{\sqrt{2}} \begin{bmatrix} 
     1 \\ 
     1 \\ 
     \end{bmatrix}\Bigg) = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     1 \\ 
     1 \\ 
     \end{bmatrix} = ∣+⟩ \\
     \therefore X∣+⟩ = Ax = \lambda x = (+1)∣+⟩ \\
         X∣-⟩ = \begin{bmatrix} 
     0 & 1 \\ 
     1 & 0 \\ 
     \end{bmatrix} \Bigg(\frac{1}{\sqrt{2}} \begin{bmatrix} 
      1 \\ 
     -1 \\ 
     \end{bmatrix}\Bigg) = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     -1 \\ 
     1 \\ 
     \end{bmatrix} = -\frac{1}{\sqrt{2}} \begin{bmatrix} 
      1 \\ 
     -1 \\ 
     \end{bmatrix} = -∣-⟩ \\
     \therefore X∣-⟩ = Ax = \lambda x = (-1)∣-⟩
     (\#eq:eigx)
\end{equation}
$$
So for the Pauli-X matrix, +1 and -1 are the eigenvalues and $∣+⟩$ and $∣-⟩$ are the eigenvectors.

In `qsimulatR` the `X` gate is available for working with Pauli-X gate.

```{r eigx}
X(1)*six_state(3)[[1]]
X(1)*six_state(4)[[1]]
```

Finally, the Pauli-Y matrix is shown in Equation \@ref(eq:pauy), and the equations for the eigenvalues and the eigenvectors are checked in Equation \@ref(eq:eigy), given the y-axis states of Equation \@ref(eq:bspy).

$$
\begin{equation}
    Y = \begin{bmatrix} 
     0 & i \\ 
     -i &  0 \\ 
     \end{bmatrix} 
     (\#eq:pauy)
\end{equation}
$$
The values +1 and -1 are the eigenvalues and $∣i⟩$ and $∣-i⟩$ are the eigenvectors of the Pauli-Y matrix.

$$
\begin{equation}
    Y∣i⟩ = \begin{bmatrix} 
     0 & i \\ 
     -i &  0 \\ 
     \end{bmatrix} \Bigg(\frac{1}{\sqrt{2}} \begin{bmatrix} 
     1 \\ 
     i \\ 
     \end{bmatrix}\Bigg) = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     i² \\ 
    -i \\ 
     \end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     -1 \\ 
     -i \\ 
     \end{bmatrix} = -∣i⟩ \\
     \therefore Y∣i⟩ = Ax = \lambda x = (-1)∣i⟩ \\
         Y∣-i⟩ = \begin{bmatrix} 
     0 & i \\ 
     -i &  0 \\  
     \end{bmatrix} \Bigg(\frac{1}{\sqrt{2}} \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix}\Bigg) = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     -i^2 \\ 
     -i \\ 
     \end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     1 \\ 
     - i \\ 
     \end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix} = ∣-i⟩ \\
     \therefore Y∣-i⟩ = Ax = \lambda x = (+1)∣-i⟩
     (\#eq:eigy)
\end{equation}
$$

The `Y` gate is available for Pauli-Y gate.

```{r eigy}
Y(1)*six_state(5)[[1]]
Y(1)*six_state(6)[[1]]
```

Therefore, the states on the x, y and z axes of the Bloch sphere are the eigenstates of the Pauli-X, Pauli-Y, and Pauli-Z matrix respectively.

The inner product is a generalization of a dot product of two vectors, resulting in a scalar. The inner product of two orthogonal vectors is 0 and the inner product of two equal vectors is 1. The inner products for the z-axis states follow as in Equation \@ref(eq:innz). In `qvirus` the `conjugate_transpose` function calculates the conjugate transpose of a given quantum state represented by a `qstate` object.

$$
\begin{equation}
    <0|1> = \begin{bmatrix} 
     1 & 0 
     \end{bmatrix} \begin{bmatrix} 
     0 \\ 
     1 \\ 
     \end{bmatrix} = (1)(0) + (0)(1) = 0 \\
     <1|0> = \begin{bmatrix} 
     0 & 1 
     \end{bmatrix} \begin{bmatrix} 
     1 \\ 
     0 \\ 
     \end{bmatrix} = (0)(1) + (1)(0) = 0 \\
     <0|0> = \begin{bmatrix} 
     1 & 0 
     \end{bmatrix} \begin{bmatrix} 
     1 \\ 
     0 \\ 
     \end{bmatrix} = (1)(1) + (0)(0) = 1 \\
     <1|1> = \begin{bmatrix} 
     0 & 1 
     \end{bmatrix} \begin{bmatrix} 
     0 \\ 
     1 \\ 
     \end{bmatrix} = (0)(0) + (1)(1) = 1
     (\#eq:innz)
\end{equation}
$$

```{r braz}
# <0| is a row vector
bra0 <- six_state(1)[[1]] |> conjugate_transpose()
bra0
# ∣1> is a col vector
bra0 %*% six_state(2)[[1]]@coefs 
# <1| is a row vector
bra1 <- six_state(2)[[1]] |> conjugate_transpose()
bra1
# ∣0> is a col vector
bra1 %*% six_state(1)[[1]]@coefs
# equal vectors
bra0 %*% six_state(1)[[1]]@coefs
bra1 %*% six_state(2)[[1]]@coefs
```

Similarily, the inner products for the x-axis states are obtained in Equation \@ref(eq:innx).

$$
\begin{equation}
    <+|+> = \frac{1}{2} \begin{bmatrix} 
     1 & 1
     \end{bmatrix} \begin{bmatrix} 
     1 \\ 
     1 \\ 
     \end{bmatrix} = \frac{1}{2}(2) = 1 \\
     <+|-> = \frac{1}{2} \begin{bmatrix} 
     1 & 1 
     \end{bmatrix} \begin{bmatrix} 
      1 \\ 
     -1 \\ 
     \end{bmatrix} = \frac{1}{2}(0) = 0 \\
     <-|+> = \frac{1}{2} \begin{bmatrix} 
     1 & -1 
     \end{bmatrix} \begin{bmatrix} 
     1 \\ 
     1 \\ 
     \end{bmatrix} = \frac{1}{2}(0) = 0 \\
     <-|-> = \frac{1}{2} \begin{bmatrix} 
     1 & -1 
     \end{bmatrix} \begin{bmatrix} 
      1 \\ 
     -1 \\ 
     \end{bmatrix} = \frac{1}{2}(2) = 1
     (\#eq:innx)
\end{equation}
$$

```{r brax}
# <+| is a row vector
brax_plus <- six_state(3)[[1]] |> conjugate_transpose()
brax_plus
# ∣-> is a col vector
brax_plus %*% six_state(4)[[1]]@coefs 
# <-| is a row vector
brax_minus <- six_state(4)[[1]] |> conjugate_transpose()
brax_minus
# ∣+> is a col vector
brax_minus %*% six_state(3)[[1]]@coefs
# equal vectors
brax_plus %*% six_state(3)[[1]]@coefs
brax_minus %*% six_state(4)[[1]]@coefs
```

And the inner product for the y-axis states are obtained in Equation \@ref(eq:inny).


$$
\begin{equation}
    <i|i> = \frac{1}{2} \begin{bmatrix} 
     1 & -i
     \end{bmatrix} \begin{bmatrix} 
     1 \\ 
     i \\ 
     \end{bmatrix} = \frac{1}{2}(1-i²) = \frac{1}{2}(2) = 1 \\
     <i|-i> = \frac{1}{2} \begin{bmatrix} 
     1 & -i 
     \end{bmatrix} \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix} = \frac{1}{2}(1+i²) = \frac{1}{2}(0) = 0 \\
     <-i|-i> = \frac{1}{2} \begin{bmatrix} 
     1 & i
     \end{bmatrix} \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix} = \frac{1}{2}(1-i²) = \frac{1}{2}(2) = 1 \\
     <-i|i> = \frac{1}{2} \begin{bmatrix} 
     1 & i 
     \end{bmatrix} \begin{bmatrix} 
     1 \\ 
     i \\ 
     \end{bmatrix} = \frac{1}{2}(1-i²) = \frac{1}{2}(0) = 0
     (\#eq:inny)
\end{equation}
$$



```{r bray}
# <i| is a row vector
bray_iplus <- six_state(5)[[1]] |> conjugate_transpose()
bray_iplus
# ∣-i> is a col vector
bray_iplus %*% six_state(6)[[1]]@coefs 
# <-i| is a row vector
bray_iminus <- six_state(6)[[1]] |> conjugate_transpose()
bray_iminus
# ∣i> is a col vector
bray_iminus %*% six_state(5)[[1]]@coefs
# equal vectors
bray_iplus %*% six_state(6)[[1]]@coefs
bray_iminus %*% six_state(5)[[1]]@coefs
```

To calculate the coordinates of the states on the Bloch sphere, the mathematical property known as the Expected Value of an Observable is considered. An observable is an operator which acts on a quantum state to give its eigenvalue and the state changes to the eigenstate. If $|psi>$ is a quantum state and M is the observable then the average value or the expected value of the observable is given by $<M> = <\psi|M|\psi>$. It can also be used to calculate the coordinates of the Bloch Sphere.

To begin with, the states on the z-axis are given by Equation \@ref(eq:staz).

$$ 
\begin{equation}
    X∣0⟩ = \begin{bmatrix} 
     0 & 1 \\ 
     1 & 0 \\ 
     \end{bmatrix} \begin{bmatrix} 
     1 \\ 
     0 \\ 
     \end{bmatrix} = \begin{bmatrix} 
     0 \\ 
     1 \\ 
     \end{bmatrix} = ∣1⟩ \\
    X∣1⟩ = \begin{bmatrix} 
     0 & 1 \\ 
     1 & 0 \\   
     \end{bmatrix} \begin{bmatrix} 
     0 \\ 
     1 \\ 
     \end{bmatrix} =  -\begin{bmatrix} 
     1 \\ 
     0 \\ 
     \end{bmatrix} = ∣0⟩ \\
     Y∣0⟩ = \begin{bmatrix} 
     0 & i \\ 
     -i &  0 \\ 
     \end{bmatrix} \begin{bmatrix} 
     1 \\ 
     0 \\ 
     \end{bmatrix} = \begin{bmatrix} 
     0 \\ 
     -i \\ 
     \end{bmatrix} = -i∣1⟩ \\
    Y∣1⟩ = \begin{bmatrix} 
     0 & i \\ 
     -i &  0 \\  
     \end{bmatrix} \begin{bmatrix} 
     0 \\ 
     1 \\ 
     \end{bmatrix} =  \begin{bmatrix} 
     i \\ 
      0 \\ 
     \end{bmatrix} =i∣0⟩ \\
    Z∣0⟩ = \begin{bmatrix} 
     1 &  0 \\ 
     0 & -1 \\ 
     \end{bmatrix} \begin{bmatrix} 
     1 \\ 
     0 \\ 
     \end{bmatrix} = \begin{bmatrix} 
     1 \\ 
     0 \\ 
     \end{bmatrix} = ∣0⟩ \\
    Z∣1⟩ = \begin{bmatrix} 
     1 &  0 \\ 
     0 & -1 \\ 
     \end{bmatrix} \begin{bmatrix} 
     0 \\ 
     1 \\ 
     \end{bmatrix} =  -\begin{bmatrix} 
     0 \\ 
     1 \\ 
     \end{bmatrix} = -∣1⟩ \\
     (\#eq:staz)
\end{equation} 
$$


```{r szax}
X(1)*six_state(1)[[1]]
X(1)*six_state(2)[[1]]
Y(1)*six_state(1)[[1]]
Y(1)*six_state(2)[[1]]
Z(1)*six_state(1)[[1]]
Z(1)*six_state(2)[[1]]
```

So, the coordinates of states $∣0⟩$ and $∣1⟩$ in z-axis are given by Equation \@ref(eq:zsta)


$$
\begin{equation}
    <0|X|0> = <0|1> = 0 \\
    <0|Y|0> = <0|i|1> = i<0|1> = 0 \\
    <0|Z|0> = <0|0> = 1 \\
    \therefore (x,y,z) = (0,0,1) \\
    <1|X|1> = <1|0> = 0 \\
    <1|Y|1> = <1|(-i)|0> = -i<1|0> = 0 \\
    <1|Z|1> = <1|(-1)|1> = -<1|> = -1 \\
    \therefore (x,y,z) = (0,0,-1)
     (\#eq:zsta)
\end{equation}
$$
```{r czax}
bra0 %*% (X(1)*six_state(1)[[1]])@coefs
bra0 %*% (Y(1)*six_state(1)[[1]])@coefs
bra0 %*% (Z(1)*six_state(1)[[1]])@coefs
bra1 %*% (X(1)*six_state(2)[[1]])@coefs
bra1 %*% (Y(1)*six_state(2)[[1]])@coefs
bra1 %*% (Z(1)*six_state(2)[[1]])@coefs
```

Analogously, the states on the x-axis are given by Equation \@ref(eq:stax).


$$
\begin{equation}
    X∣+⟩ = \begin{bmatrix} 
     0 & 1 \\ 
     1 & 0 \\ 
     \end{bmatrix} \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
     1 \\ 
     1 \\ 
     \end{bmatrix} =  \frac{1}{\sqrt{2}} \begin{bmatrix} 
     1 \\ 
     1 \\ 
     \end{bmatrix} = ∣+⟩ \\
    X∣-⟩ = \begin{bmatrix} 
     0 & 1 \\ 
     1 & 0 \\   
     \end{bmatrix}  \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
      1 \\ 
     -1 \\ 
     \end{bmatrix} =  \frac{1}{\sqrt{2}} \begin{bmatrix} 
     -1 \\ 
      1 \\ 
     \end{bmatrix} = -∣-⟩ \\
     Y∣+⟩ = \begin{bmatrix} 
     0 & i \\ 
     -i &  0 \\ 
     \end{bmatrix}  \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
     1 \\ 
     1 \\ 
     \end{bmatrix} =  \frac{1}{\sqrt{2}} \begin{bmatrix} 
     i \\ 
      -i \\ 
     \end{bmatrix} = i∣-⟩ \\
    Y∣-⟩ = \begin{bmatrix} 
     0 & i \\ 
     -i &  0 \\  
     \end{bmatrix}  \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
      1 \\ 
     -1 \\ 
     \end{bmatrix} =  \frac{1}{\sqrt{2}} \begin{bmatrix} 
     -i \\ 
     -i \\ 
     \end{bmatrix} = -i∣+⟩ \\
    Z∣+⟩ = \begin{bmatrix} 
     1 &  0 \\ 
     0 & -1 \\ 
     \end{bmatrix}  \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
     1 \\ 
     1 \\ 
     \end{bmatrix} =  \frac{1}{\sqrt{2}} \begin{bmatrix} 
      1 \\ 
     -1 \\ 
     \end{bmatrix} = ∣-⟩ \\
    Z∣-⟩ = \begin{bmatrix} 
     1 &  0 \\ 
     0 & -1 \\ 
     \end{bmatrix}  \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
      1 \\ 
     -1 \\ 
     \end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     1 \\ 
     1 \\ 
     \end{bmatrix} = ∣+⟩ \\
     (\#eq:stax)
\end{equation}
$$

```{r sxax}
X(1)*six_state(3)[[1]]
X(1)*six_state(4)[[1]]
Y(1)*six_state(3)[[1]]
Y(1)*six_state(4)[[1]]
Z(1)*six_state(3)[[1]]
Z(1)*six_state(4)[[1]]
```

And the coordinates of states $∣+⟩$ and $∣-⟩$ in x-axis are given by Equation \@ref(eq:xsta).


$$
\begin{equation}
    <+|X|+> = <+|+> = 1 \\
    <+|Y|+> = <+|(-i)|-> = -i<+|-> = 0 \\
    <+|Z|+> = <+|-> = 0 \\
    \therefore (x,y,z) = (1,0,0) \\
    <-|X|-> = <-|(-1)|-> = -<-|-> = -1 \\
    <-|Y|-> = <-|(i)|+> = i<-|+> = 0 \\
    <-|Z|-> = <-|+> = 0 \\
    \therefore (x,y,z) = (-1,0,0)
     (\#eq:xsta)
\end{equation}
$$


```{r cxax}
brax_plus %*% (X(1)*six_state(3)[[1]])@coefs
brax_plus %*% (Y(1)*six_state(3)[[1]])@coefs
brax_plus %*% (Z(1)*six_state(3)[[1]])@coefs
brax_minus %*% (X(1)*six_state(4)[[1]])@coefs
brax_minus %*% (Y(1)*six_state(4)[[1]])@coefs
brax_minus %*% (Z(1)*six_state(4)[[1]])@coefs
```

For the states on the y-axis, the same procedure follows and they are given in Equation \@ref(eq:stay).


$$
\begin{equation}
    X∣i⟩ = \begin{bmatrix} 
     0 & 1 \\ 
     1 & 0 \\ 
     \end{bmatrix} \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
     1 \\ 
     i \\ 
     \end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     i \\ 
     1 \\ 
     \end{bmatrix} = i\Bigg(\frac{1}{\sqrt{2}}\Bigg) \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix} = i∣-i⟩ \\
    X∣-i⟩ = \begin{bmatrix} 
     0 & 1 \\ 
     1 & 0 \\   
     \end{bmatrix}  \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix} =  \frac{1}{\sqrt{2}} \begin{bmatrix} 
     -i \\ 
      1 \\ 
     \end{bmatrix} = -i \Bigg(\frac{1}{\sqrt{2}}\Bigg) \begin{bmatrix} 
     1 \\ 
     i \\ 
     \end{bmatrix} = -i∣i⟩ \\
     Y∣i⟩ = \begin{bmatrix} 
     0 & i \\ 
     -i &  0 \\ 
     \end{bmatrix}  \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
     1 \\ 
     i \\ 
     \end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     i² \\ 
     - i \\ 
     \end{bmatrix} = -\frac{1}{\sqrt{2}} \begin{bmatrix} 
     1 \\ 
     i \\ 
     \end{bmatrix} = -∣i⟩ \\
    Y∣-i⟩ = \begin{bmatrix} 
     0 & i \\ 
     -i &  0 \\  
     \end{bmatrix}  \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix} =  \frac{1}{\sqrt{2}} \begin{bmatrix} 
     -i² \\ 
     -i \\ 
     \end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix} = ∣-i⟩ \\
    Z∣i⟩ = \begin{bmatrix} 
     1 &  0 \\ 
     0 & -1 \\ 
     \end{bmatrix}  \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
     1 \\ 
     i \\ 
     \end{bmatrix} =  \frac{1}{\sqrt{2}} \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix} = ∣-i⟩ \\
    Z∣-i⟩ = \begin{bmatrix} 
     1 &  0 \\ 
     0 & -1 \\ 
     \end{bmatrix}  \Big(\frac{1}{\sqrt{2}}\Big) \begin{bmatrix} 
      1 \\ 
     -i \\ 
     \end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix} 
     1 \\ 
     i \\ 
     \end{bmatrix} = ∣i⟩ \\
     (\#eq:stay)
\end{equation}
$$


```{r syax}
X(1)*six_state(5)[[1]]
X(1)*six_state(6)[[1]]
Y(1)*six_state(5)[[1]]
Y(1)*six_state(6)[[1]]
Z(1)*six_state(5)[[1]]
Z(1)*six_state(6)[[1]]
```

Finally, the coordinates of states $∣i⟩$ and $∣-i⟩$ in y-axis are given by Equation \@ref(eq:ysta).


$$
\begin{equation}
    <i|X|i> = <i|(i)|-i> = i<i|-i> = i(0) = 0 \\
    <i|Y|i> = -<i|i> = -1 \\
    <i|Z|i> = <i|-i> = 0 \\
    \therefore (x,y,z) = (0,-1,0) \\
    <-i|X|-i> = <-i|(-i)|i> = -i<-i|i> = 0 \\
    <-i|Y|-i> = <-i|-i> = 1 \\
    <-i|Z|-i> = <-i|i> = 0 \\
    \therefore (x,y,z) = (0,1,0)
     (\#eq:ysta)
\end{equation}
$$


```{r cyax}
bray_iplus %*% (X(1)*six_state(5)[[1]])@coefs
bray_iplus %*% (Y(1)*six_state(5)[[1]])@coefs
bray_iplus %*% (Z(1)*six_state(5)[[1]])@coefs
bray_iminus %*% (X(1)*six_state(6)[[1]])@coefs
bray_iminus %*% (Y(1)*six_state(6)[[1]])@coefs
bray_iminus %*% (Z(1)*six_state(6)[[1]])@coefs
```

Using the `pure_qubit1` function with the `spherical` argument set to `TRUE`, a normalized pure quantum state gets represented as a point r in the Bloch sphere.    

```{r bsph}
# Define |0>
theta <- 0
phi <- 0

# Create the point on +z-axis in Bloch sphere
pure_qubit1(theta, phi, spherical = TRUE)
```

# Quantum Gates

Quantum gates are fundamental components of quantum computing, enabling the manipulation and transformation of qubits, the building blocks of quantum information. Here's a structured section on quantum gates that integrates both theoretical explanations and practical implementation using `qsimulatR`.

## Introduction to Quantum Gates

Quantum gates are unitary transformations that act on qubits, changing their states and enabling quantum computations. They play a crucial role in quantum algorithms and are based on linear quantum operators represented by unitary matrices.

## Properties of Quantum Gates

- Unitary Transformations: Quantum gates are represented by unitary matrices, ensuring reversibility and preservation of quantum information.

- Linearity: They follow linear operations, essential for quantum superposition and entanglement phenomena.

- Gate Combinations: Combining quantum gates allows for the creation of complex quantum algorithms.

## Pauli Gates

### Pauli-X Gate (Bit Flip):

The Pauli-X gate corresponds to a classical NOT operation, flipping the computational basis states $|0⟩$ and $|1⟩$. Its matrix representation is a Pauli-X matrix.

```{r xmat}
X(1)@M
```

The action of the X gate is visualized using the `plot` function:

```{r xplo}
(X(1)*six_state(1)[[1]]) |> plot(qubitnames = "|0>")
```

### Pauli-Y Gate (Bit & Phase Flip):

The Pauli-Y gate combines a bit flip and a phase flip, interchanging $|0⟩$ and $|1⟩$ and applying a relative phase. Its matrix representation:

```{r ymat}
Y(1)@M
```

For visualization:

```{r yplo}
(Y(1)*six_state(1)[[1]]) |> plot(qubitnames = "|0>")
```

### Pauli-Z Gate (Phase Flip):

The Pauli-Z gate flips the phase of the $|1⟩$ state relative to $|0⟩$ in the computational basis. Matrix representation:

```{r zmat}
Z(1)@M
```

Plotting the action of the Z gate gives:

```{r zplo}
(Z(1)*six_state(1)[[1]]) |> plot(qubitnames = "|0>")
```

### Hadamard Gate

The Hadamard gate creates a uniform superposition, crucial for quantum algorithm initialization. Its matrix representation:

```{r hmat}
H(1)@M
```

Visualization of the action of the Hadamard gate is inherited from the `plot` method:

```{r hplo}
# H.|0>
(H(1)*six_state(1)[[1]]) |> plot(qubitnames = "|0>")
```

### Other Quantum Gates

- S Gate (Phase Gate Z90): Adds a $90°$ rotation to the phase, useful in phase manipulation.
- T Gate (Phase Gate): Performs a quarter of the Z gate and a half of the S gate, providing additional phase control.

Visualization of the action of the S gate using the plot function:

```{r splo}
(S(1)*six_state(1)[[1]]) |> plot(qubitnames = "|0>")
```

The T gate performs a quarter of the Z gate and a half of the S gate.

## Implementation with qsimulatR and qvirus

Using `qsimulatR` and `qvirus`, one can create, visualize, and analyze quantum gates and circuits. For example:

- Creating a Hadamard gate: `H(1)`
- Applying a gate to a quantum state: `H(1)*six_state(1)[[1]]`
- Visualization: `(H(1)*six_state(1)[[1]]) |> plot(qubitnames = "|0>")`

## Conclusion

Quantum gates are foundational to quantum computing, enabling the execution of quantum algorithms and the manipulation of quantum information. 

Visualizing quantum gates using the enhances the understanding of their operations in quantum circuits. This visualization is crucial for grasping the geometric interpretations and practical implications of various quantum gates.
